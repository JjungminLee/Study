## 공유 메모리 아키텍쳐

- 모든 구성 요소를 단일장비처럼 다룰 수 있다
- 문제점
  - 비용이 선형적인 추세보다 훨씬 빠르게 증가함
    - 두배 많은 CPU, 두배 많은 RAM, 두배 많은 디스크 용량을 갖춘 시스템은 두배 이상의 비용이 소요
  - 제한적인 내결함성 제공

## 비공유 아키텍쳐

- 수평 확장
- 각 장비나 가상 장비를 노드라고 부른다
- 각 노드는 CPU나 RAM을 독립적으로 사용한다.
- 노드간 coordination은 일반적인 네트워크를 사용해 소프트웨어 수준에서 사용
- 특별한 하드웨어 필요로 하지 않음
- 잠재적으로 여러 지리적인 영역에 걸쳐 데이터를 분산해 사용자 지연시간을 줄이고 전체 데이터 센터의 손실을 줄일 수 있다.

### 복제 대 파티셔닝

- 복제
  - 같은 데이터의 복사본을 잠재적으로 다른 위치에 있는 여러 노드에 유지한다.
  - 복제는 중복성을 제공한다.
  - 일부 노드가 사용 불가능 상태라면 해당 데이터는 남은 다른 노드를 통해 여전히 제공할 수 있다
  - 성능 향상에도 도움이 된다
- 파티셔닝
  - 큰 데이터베이스를 파티션이라는 작은 서브셋으로 나누고 각 파티션은 각기 다른 노드에 할당한다
    - 샤딩이라고 한다

## 복제

- 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미
  - 지리적으로 사용자와 가깝게 유지해 지연시간을 줄인다
  - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다
  - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다
- 복제의 어려움은 어디서 얼까?
  - 복제된 데이터들이 변경됐을때!
  - 노드간 변경을 복제하기 위한 세가지 인기있는 알고리즘이 존재
    - 단일 리더
    - 다중 리더
    - 리더 없는 복제

### 리더와 팔로워

- 데이터베이스의 복사본을 저장하는 각 노드를 복제 서버라고 한다.
  - 레플리카
- 데이터의 모든 쓰기는 모든 복제 서버에서 처리돼야함
  - 안그러면 일관성 있는 데이터가 유지되지 않음
    - 해결책은 리더기반 복제 또는 마스터-슬레이브 복제
  - 복제 서버 중 하나를 리더라고 지정
    - 클라이언트가 데이터베이스에 쓰기를 할때 클라이언트는 요청을 리더에게 보내야
    - 리더는 먼저 로컬 저장소에 새로운 데이터 기록
  - 다른 복제 서버는 팔로워 또는 슬레이브 또는 2차 핫 대기
    - 리더가 로컬 저장소에 새로운 데이터 기록할 때마가 데이터 변경을 복제로그나 변경 스트림의 일부로 팔로워에게 전송
    - 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로겈 복사본 갱신
    - 클라이언트가 디비로부터 읽기를 할때는 리더 또는 임의 팔로워에게 질의 가능, 쓰기는 리더만 허용

### 동기식 대 비동기식 복제

- 동기식
  - 리더는 팔로워1이 수신했는지 확인해줄때까지 기다림
  - 팔로워가 리더와 일관성 있게 최신 데이터 복사본 가지는 것을 보장함
  - 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없음
  - 리더는 모든 쓰기를 차단하고 동기 복제 서버가 다시 사용할 수 있을때까지 기다려야함
  - 현실적으로 동기식 복제를 사용하려면
    - 팔로워 하나는 동기식으로 하고, 그 밖에는 비동기식으로 하는
    - 동기식 팔로워가 사용할수 없게 되거나 느려지면 비동기식 팔로워중 하나가 동기식이 된다
      - 반동기식
- 비동기식
  - 리더는 메세지를 전송하나 팔로워의 응답을 기다리지 않음
  - 리더 기반 복제
    - 리더가 잘못되고 복구될 수 없으면 팔로워에게 아직 복제되지 않은 모든 쓰기는 유실된다
  - but 모든 팔로워가 잘못되더라도 리더가 쓰기처리를 계속할 수 있는 장점이 있다

### 새로운 팔로워 설정

- 복제 서버 수를 늘리거나 장애노드의 대체를 위해 새로운 팔로워를 설정해야하는 상황이 생김
  - 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장?
    - 데이터 베이스를 잠근는 방법은 디스크를 일관성 있게 만들수는 있겠지만 가용성은 별로임
    - 방법
      - 가능한 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅샷을 일정 시점에 가져오기
      - 스냅샷을 새로운 팔로워 노드에 복사하기
      - 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경을 요청
        - 스냅샷이 리더의 복제 로그의 정확한 위치와 관련돼야
        - 팔로워가 스냅샷 이후 데이터 변경의 미처리분을 모두 처리했을때 따라잡았다고 말함

## 노드 중단 처리

### 따라잡기 복구

- 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관
- 팔로워가 죽어 재시작하거나 리더워 팔로워 사이의 네트워크가 일시적으로 중단 시 -> 팔로워가 매우 쉽게 복구 가능

### 장애복구

- 팔로워 중 하나를 새로운 리더로 승격시켜야함
- 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정 필요
- 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야
- 자동 장애복구 흐름
  - 리더가 장애인지 판단
  - 새로운 리더 선택
  - 새로운 리더 사용 위해 시스템 재설정

## 복제로그 구현

### 구문 기반 복제

- 리더는 모든 쓰기 요청을 기록하고 쓰기를 실행하고, 구문 로그를 팔로워에게 전송한다
- 관계형 데이터베이스는 모든 INSERT,UPATE,DELETE구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에 직접 받은것처럼 SQL 구문파싱하고 실행
- 문제
  - 시스템마다 rand()의 호출값 다름
  - Auto-Increment 컬럼이라면?

### 쓰기 전 로그 배송

- 로그 구조화 저장소 엔진(SS테이블과 LSM트리)
  - 로그 자체가 저장소의 주요 부분
- 개별 디스크 블록에 덮어쓰는 B트리
  - 모든 변경은 쓰기 전 로그 (WAL)
    - 고장 이후 일관성 있는 상태로 인덱스 복원 가능

### 논리적 로그 복제 (ROW기반)

- 복제로그를 저장소 엔진 내부와 분리하기 위해서
  - 복제 로그와 저장소 엔진 내부 둘 다 다른 형식을 사용하기
- 관계형 데이터베이스용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술함
- 여러 row를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다
  - MySQL의 이진로그가 이걸 사용!

### 트리거 기반 복제

- 데이터의 서브셋만 복제하거나 데이터 베이스를 다른 종류의 데이터베이스로 복제해야하거나 충돌해소 로직이 필요하다면 복제를 애플리케이션 계층으로 옮겨야
- 오버헤드 겁나큰데 유연함

## 복제 지연문제

- 리더 부하를 없애고 근처 복제 서버에서 읽기요청 처리 가능

### 쓰기 후 일관성

- 비동기식 복제에서는 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터가 복제서버에 반영되지 않았을수도 있음
  - 사용자에게 유실된 것처럼 보임
  - 쓰기 후 일관성이 필요하다고 함
- 어떻게 구현?
  - 사용자가 수정한 내용을 읽을때는 리더에서 읽기
    - 그 밖에는 팔로워에서 읽기
  - 애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면 이 접근 방식은 대부분 리더에서 읽기 때문에 효율적이지 않음

### 단조 읽기

- 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않음

### 일관된 순서로 읽기

- 샤딩(파티셔닝)된 데이터베이스에서 발생하는 문제
- 분산 데이터 베이스는 서로 다른 파티션은 독립적으로 동작하기에 쓰기의 전역 순서가 없다!

## 다중 리더 복제

- 앞에는 단일리더복제만 살펴봄
  - 단점?
    - 리더가 하나만 존재하고 모든 쓰기는 리더를 거쳐야
- 다중리더는 쓰기를 허용하는 노드를 하나이상 두는 것
- 사례
  - 다중 데이터 센터 운영
- 단점
  - 동일한 데이터를 두개의 데이터 센터에서 동시에 변경
    - 쓰기 충돌을 해소해야

### 협업편집

- 구글독스 같은거
- 한 사용자가 문서를 편집할때 변경 내용을 즉시 로컬 복제 서버에 적용하고 나서 동일한 문서를 편집하는 다른 사용자와 비동기 방식으로 복제해야!
- 편집 충돌이 없음을 보장하려면 애플리케이션은 사용자가 편집하기 전에 문서의 잠금을 얻야함
  - 빠르게 하려면 변경 단위를 매우 작게해서 잠금을 할수도 있음

### 쓰기 충돌

- 다중 리더 복제의 가장 큰 문제
- 충돌회피 전략
  - 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 보장
- 일관 상태 수렴
  - 다중리더는 쓰기 순서가 부정확
  - 수렴방식으로 충돌을 해소해야
    - 모든 변경이 복제돼 모든 복제 서버에 동일한 최종값이 전달되게
  - 방법?
    - 각 쓰기에 고유 id부여하고 높은 id를 가진 쓰기 고르기
- 사용자 정의 충돌 해소 로직
  - 전체 트랜잭션이 아닌 개별 row나 문서 수준에 적용

## 다중리더 복제 토폴로지

- 복제 토폴로지
  - 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로
- 전체 연결
  - 모든 리더가 각자의 쓰기를 다른 모든 리더에서 전송
- 원형 토폴로지
  - MySQL
  - 각 노드가 하나의 노드로부터 쓰기 받고 쓰기를 다른 한노드에 전달
- 별 토폴로지
  - 지정된 루트 노드 하나가 다른 모든 노드에 쓰기 전달
- 단점
  - 원형,별
    - 하나의 노드에 장애 발생 시 다른 노드간 복제 메세지 흐름에 방해
  - 전체연결
    - 일부 네트워크 연결이 다른 연결보다 빠르면 일부 복제 메세지가 다른 메세지 추월 가능

## 리더 없는 복제

- 지금까지 단일리더와 다중리더복제는 클라이언트가 쓰기 요청을 리더에 전송 후 -> 데이터베이스 시스템이 쓰기를 다른 복제 서버에 복사를 처리하는 아이디어를 기반으로함
- 모든 복제서버가 클라이언트로부터 쓰기를 직접 받을수 있게 허용하는 접근방식을 사용하기도 함.
  - 대표적으로 dynamo db

### 노드가 다운됐을때 데이터베이스에 쓰기

- 세개의 복제 서버를 가진 디비가 있고 복제 서버 중 하나를 사용할 수 없을때
  - 리더 기반 설정은 쓰기처리 계속하려면 장애복구 해야
  - 리더가 없으면 장애복구 필요 없음
    - 나머지 두개가 병렬로 받음

### 동시성?

- 각 작업이 서로 알지 못하면 단순히 두 작업은 동시에 수행됐다 말함

## 동시에 쓴 값 병합하기

- 어떤 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야한다.
- 이런 동시값을 **형제값**이라고 부른다!
  - 중복된 상품을 제거할때 단순히 데이터 베이스에서 삭제하는게 아니라
  - 형제 병합할때 상품을 제거했음을 나타내기 위해 버전번호를 표시
    - 이걸 툼스톤이라고 함

## Recap

- 복제는 언제 사용할까?
  - 고가용성
    - 한 장비가 다운될때도 시스템이 계속 동작하게
  - 연결이 끊긴 작업
    - 네트워크가 중단됐어도 계속 동작하게
  - 지연시간
  - 확장성
- 접근밥법
  - 단일리더 복제
  - 다중리더복제
  - 리더없는 복제
