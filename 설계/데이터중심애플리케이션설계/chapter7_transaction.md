## ACID

- 원자성 일관성 격리성 지속성
- 원자성
  - 동시성과 관련이 없음
  - 클라이언트가 쓰기 작업 몇개를 실행하는데 일부만 처리후 결함이 생기면 무슨 일이 생기는지 설명
  - 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함때문에 커밋될수 없다면 어보트됨
- 일관성
  - 회계 시스템에서 대변과 차변은 항상 맞아떨어져야 한다
- 격리성
  - 동일한 데이터베이스 레코드에 접근하면 동시성문제(경쟁조건)에 맞닥뜨림
  - 트랜잭션은 다른 트랜잭션을 방해할수 없다
  - 격리성을 직렬성이라고도 함
- 지속성
  - 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다

### 다중 객체 트랜잭션

- 여러 파티션에 걸쳐 구현하기 어려움
- 문서 데이터 모델은 함께 갱신돼야하는 필드들이 단일 객체로 다뤄지는 동일한 문서내에 존재하는 경우가 흔함.
- 단일 문서 갱신시 다중 객체 트랜잭션이 필요없음

## 완화된 격리수준과 발생할 수 있는 경쟁조건

### 커밋 후 읽기

- 커밋만 데이터만 보고, 커밋된 데이터만 덮어씀
- 더티 읽기 방지
  - **커밋되지 않은 데이터 보는걸 더티 읽기**
  - 더티읽기 막는게 유용한 경우
    - 트랜잭션이 여러 객체 갱신시
- 더티 쓰기 방지
  - **먼저 쓴 내용이 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기작업이 커밋되지 않은 값을 덮어써버린다면?**
    - **이걸 더티쓰기라고 부름**
    - 커밋 후 읽기 수준에서 실행되는 트랜잭션은 더티쓰기 방지해야
- 어떻게 구현?
  - row수준 잠금을 사용해 더티쓰기 방지
  - 오직 하나의 트랜잭션만 어떤 주어진 객체에 대한 잠금 보유
  - 더티 읽기 막는 방법
    - 동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금 획득한 후 읽기가 끝난다음에 바로 해제하게 하는 것
    - 이러면 객체가 변경됐으나 아직 커밋되지 않은 값을 갖고 있을때 읽기가 실행되지 않도록 보장
  - but 읽기 잠금은 현실에서 잘 동작하지 않음
    - 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될때까지 기다려야

### 스냅숏 격리와 반복읽기

- 비 반복 읽기 (읽기 skew)
  - 트랜잭션이 처리되고 있는 시점에 데이터를 보는 것
  - 보통 웹서비스의 경우 새로고침하면 해결됨
  - 문제가 되는 경우
    - 백업
    - 분석질의와 무결성 확인
  - 이때 해결책이 스냅숏 격리
    - 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다
    - 트랜잭션은 시작할때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다
- 구현?
  - 쓰기 잠금을 사용
  - 읽을때는 잠금 필요없음
  - 데이터베이스는 객체마다 커밋된 버전 여러개를 유지할수 있어야한다
    - 다중 버전 동시성 제어

### 스냅샷격리가 필요한 이유?

데이터베이스 트랜잭션에서는 **데이터 일관성(Consistency)과 동시성(Concurrency)** 이 중요한데, 두 가지를 모두 만족하는 것이 쉽지 않음

✅ **읽기 트랜잭션이 오래 걸리는 쓰기 트랜잭션 때문에 차단되지 않아야 함.**  
✅ **쓰기 트랜잭션은 일관된 데이터를 기반으로 실행되어야 함.**  
✅ **읽기 작업 중에 데이터가 변경되더라도, 읽기 트랜잭션이 일관된 데이터를 유지해야 함.**

#### 방식

스냅샷 격리는 **트랜잭션이 시작될 때 데이터를 "스냅샷"으로 저장하고, 그 시점의 데이터를 계속 읽도록 하는 방식**
1️⃣ **읽기 트랜잭션 시작**

- 트랜잭션이 시작될 때, **그 시점의 데이터를 복사(스냅샷 생성)**
- 이후에는 이 스냅샷을 기반으로 데이터를 조회함
- → 즉, 다른 트랜잭션이 데이터를 변경해도 **트랜잭션이 시작된 시점의 데이터를 계속 읽을 수 있음**

2️⃣ **쓰기 트랜잭션이 변경을 시도해도 기존 트랜잭션에 영향 없음**

- 하나의 트랜잭션이 데이터를 수정한다고 해도, 읽기 트랜잭션은 **트랜잭션 시작 시점의 데이터만 확인**
- 따라서 **읽기 트랜잭션이 쓰기 트랜잭션을 기다릴 필요 없음** (즉, `READ COMMITTED`와 다름)

## 갱신손실 방지

- 동시에 실행되는 쓰기 트랜잭션 사이에 발생할수 있는 쓰기 충돌
- 값을 읽고 변경한 후 변경된 값을 다시 쓸때 발생

### 원자적 쓰기 연산

- 원자적 갱신연산 제공

### 명시적인 잠금

- 첫번째 read-modify-write 주기가 끝날때까지 기다리도록 강제함

### 갱신손실 감지

    - 애플리케이션 코드에서 특별한 디비 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능
    - 잠금이나 원자적 연산 쓰는걸 잊어버렸을때 갱신손실이 감지되어 오류가 덜 발생하게 해줌

### compare and set

- 트랜잭션을 제공하지 않는 디비중에는 원자적 compare and set을 제공하기도 함
- 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신 허용하므로 갱신손실 회피
- 두명의 사용자가 동시에 위키페이지를 편집한다면?

```
update wiki_pages set content= 'new_content'
	where id=1234 and content = 'old_content'
```

### 복제가 적용된 디비의 갱신손실 막기

- 한 값에 대해 여러개의 충돌된 버전을 생성하는 것을 허용하고 나중에 해소하기

### 쓰기 스큐

**서로 다른 트랜잭션이 각자 데이터를 읽고 수정하지만, 변경이 충돌하지 않아서 트랜잭션이 정상적으로 커밋되는 문제**  
→ **하지만 결과적으로 데이터 무결성이 깨짐**

### **🔥 예제 1: 병원 근무 교대 시스템**

#### **🛑 문제 상황**

1. 병원에서 **의사는 두 명 이상 근무해야 한다**는 규칙이 있음.
2. **A와 B가 동시에 퇴근 신청을 함!**

   - `T1 (A의 트랜잭션)` → "현재 근무 중인 의사가 2명이니까 내가 나가도 최소 1명은 남겠지!" → `DELETE A`
   - `T2 (B의 트랜잭션)` → "현재 근무 중인 의사가 2명이니까 내가 나가도 최소 1명은 남겠지!" → `DELETE B`

3. **둘 다 문제가 없다고 판단하여 각각의 트랜잭션이 커밋됨.**
4. **결과적으로 의사가 아무도 없게 됨. (데이터 무결성 깨짐)**

#### **왜 발생하는가?**

- 두 개의 트랜잭션이 각각 데이터를 읽고, 다른 데이터를 수정하기 때문에 직접적인 충돌이 없음.
- 하지만 두 트랜잭션이 **같은 데이터를 기반으로 의사결정을 하고 있는데**, 동시에 실행되면서 **데이터 정합성이 깨지는 문제**가 발생.

### 팬텀리드

한 트랜잭션에서 동일한 조건으로 여러 번 데이터를 조회했을 때, **중간에 다른 트랜잭션이 데이터를 삽입/삭제하여 결과가 달라지는 문제**

### **🔥 예제 2: 은행 계좌의 최소 잔액 유지**

#### **🛑 문제 상황**

1. 은행에서는 고객의 계좌가 최소한 **잔액 500달러 이상을 유지해야 한다**.
2. `T1 (관리자의 트랜잭션)`이 모든 계좌를 조회하여 잔액이 500달러 미만이면 경고 메시지를 보내려고 함
3. `T2 (사용자의 트랜잭션)`이 실행되면서, **새로운 계좌를 개설하고 잔액 100달러로 추가**
4. `T1`이 동일한 쿼리를 다시 실행하면, **방금 추가된 100달러 계좌가 조회됨!**

- 즉, **같은 트랜잭션 내에서 조회 결과가 달라짐** → 팬텀 리드 발생!

## 해결책 : 직렬성 격리

- 여러 트랜잭션이 병렬로 실행되더라도 최종결과는 동시성 없이 한번에 하나씩 직렬로 실행할때와 같도록 보장함
- 데이터 베이스가 발생할 수 있는 모든 경재조건을 막아줌

### 어떻게 실행될까?

- 한번에 트랜잭션 하나씩만 직렬로 단일스레드에서 실행하기
- 모든 트랜잭션은 작고 빨라야함
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한됨
- 쓰기 처리량이 단일 CPU코어에서 처리할 ㅅ 있을 정도로 충분히 낮아야

### 2단계 잠금

- 쓰기 뿐만 아니라 읽기 트랜잭션도 진행되지 못하게 막는 것
- 잠금은 공유모드나 독점모드로 사용됨
  - 트랜잭션이 객체를 읽기 원한다면 공유모드로 잠금을 획득해야한다
  - 트랜잭션이 객체에 쓰기를 원한다면 독점모드의 잠금을 획득해야
  - 트랜잭션이 객체를 읽다 쓰면 공유잠금을 독점 잠금으로 업그레이드 해야
  - 트랜잭션이 잠금을 획득한 후 트갠잭션이 종료될때까지 잠금을 자기오 있어야한다
- 성능이 구림
- 직렬성 격리가 팬텀을 막기 위해서 서술잠금 predicate lock이 필요함
  - 어떤 조건에 부합하는 객체를 읽기 원한다면 where를 통해
  - 질의의 조건에 대한 공유 모드 서술잠금을 획득해야
- 요즘은 서술잠금이 아닌 색인범위 잠금 사용

## 비관적 동시성 제어 vs 낙관적 동시성 제어

- 2단계 잠금은 비관적 동시성 제어 메커니즘
- 상호배제와 비슷
- 직렬적 스냅샷 격리는 낙관적 동시성 제어 기법
- 예비용량이 충분하고 트랜잭션 사이에 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법이 성능이 더 좋음

## ✅ Recap

- 경쟁조건
  - 더티 읽기
  - 더티 쓰기
  - 읽기 스큐 (비반복 읽기)
  - 갱신 손실
  - 쓰기 스큐
  - 팬텀읽기
- 해결책 : 직렬성 트랜잭션
  - 트랜잭션 순서대로 실행
  - 2단계 잠금
  - 직렬성 스냅숏 격리
