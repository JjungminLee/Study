- 작업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진 내부에서 수행되는 작업을 이해할 필요가 있다!
- 저장소 엔진
  - 로그 구조 계열
    - B-tree
  - 페이지 지향 계열

## 색인

- 부가적인 메타데이터를 유지하는 것
- 원하는 데이터의 위치를 찾는데 도움을 준다
- 기본데이터에서 파생된 추가적인 구조
- index는 읽기 성능을 키우지만 쓰기 성능은 떨어뜨린다
  - 자동으로 모든것을 색인하지 않는다

### 해시 색인

- 딕셔너리 타입
- 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시맵을 유지
  - 비트캐스크가 자주 사용하는 방식
    - 해시맵을 전부 메모리에 유지
      - 램에 모든 키가 저장된다는 전제로 고성능 읽기,쓰기 보장
    - 비스캐스크 같은 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합
      - 키 : 비디오 url , 값 : 비디오가 재생된 횟수
  - 파일에 항상 추가만 하면 디스크가 부족해진다!
    - 특정 크기의 세그먼트로 로그를 나누는 방식이 좋은 해결책!
    - 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 이후 쓰기를 수행하기
    - 세그먼트 파일들에 대해 컴팩션을 수행할 수 있다!
      - 중복 키 버리고 최신으로 갱신된값만 유지
- 구현에서 고려해야하는 중요한 문제
  - 파일 형식
    - csv는 적합하지 않다
  - 레코드 삭제
    - 키와 관련된 값 삭제하려면 데이터 파일에 특수한 삭제 레코드 추가해야함
  - 고장 복구
    - 데이터베이스가 재시작되면 인메모리 해시맵이 손실됨
      - 세그먼트 파일이 크면 해시맵 복원은 오랜시간이 걸릴 수 있음
      - 비트캐스크는 각 세그먼트 해시맵을 메모리로 조금 더 빠르게 로딩할 수 있게 스냅샷을 디스크에 저장해 복구 속도를 높인다
  - 부분적 레코드 쓰기
    - 로그에 레코드 추가하는 도중에 죽을 수 있음
    - 체크섬을 추가하면 로그의 손상된 부분 탐지가능
  - 동시성 제어
    - 하나의 쓰기 스레드만!
    - 읽기의 경우 불변이기에 다중 스레드 가능

### +) 추가 전용(append-only) 로그 파일

- 기존 로그를 덮어쓰지 않고, 새로운 로그를 계속 추가하는 방식의 로그 파일.
- 데이터베이스의 **Write-Ahead Logging (WAL)**, **Apache Kafka의 로그 구조**, **Git의 변경 이력 저장 방식** 등이 대표적인 예시.
- **특징:**
  - 기존 데이터 수정 없이 기록만 추가됨.
  - 로그를 통한 변경 이력 추적이 가능함.
  - 장애 발생 시 복구가 용이함.
- 1️⃣ **데이터 무결성 보장 (Integrity & Audit Trail)**

- **기존 로그를 수정하거나 삭제할 수 없도록 설계**하면, 시스템의 변경 이력을 신뢰할 수 있음.
- 예를 들어, 금융 시스템이나 블록체인 같은 환경에서는 기록을 변경하지 않고 그대로 보존해야 함.
- "누가 언제 무엇을 변경했는지"를 명확하게 남길 수 있음.

💡 **예제**

- Git의 커밋 로그
- 데이터베이스의 WAL(Write-Ahead Logging)
- 감사 로그(Audit Logs)

---

- 2️⃣ **장애 복구 및 재현 가능성 (Recovery & Replay)**

- 시스템 장애가 발생했을 때, **로그를 기반으로 원래 상태를 복구**할 수 있음.
- 예를 들어, 데이터베이스에서 **Write-Ahead Logging (WAL)**을 사용하면, 데이터 손실 없이 복구 가능.
- 이벤트 소싱(Event Sourcing) 시스템에서는 로그를 다시 재생(replay)해서 상태를 재구성할 수 있음.

💡 **예제**

- PostgreSQL, MySQL InnoDB의 WAL
- Kafka의 로그 기반 메시지 큐
- Event Sourcing 패턴을 적용한 시스템

---

- 3️⃣ **고성능 및 동시성 처리 (Performance & Concurrency)**

- 파일을 덮어쓰는 것은 **동기화(locking) 문제**가 발생할 수 있음. 여러 개의 프로세스가 동시에 로그를 기록하면 충돌이 날 수 있음.
- **Append-only 방식**은 기존 데이터를 변경하지 않고, 항상 끝에 새로운 데이터를 추가하기 때문에 **경쟁 조건(race condition)이 줄어듦**.
- SSD와 같은 저장 매체에서 **덮어쓰기보다 추가가 더 빠름**(특히 순차 쓰기 성능이 좋은 경우).

💡 **예제**

- Kafka의 로그 기반 처리 시스템
- LSM-Tree 기반 데이터베이스 (RocksDB, LevelDB)
- 분산 시스템에서의 로깅

## SS 테이블과 LSM 트리

- 키로 정렬된 형식을 정렬된 문자열 테이블
  - SS테이블
  - 각 키는 각 병합된 세그먼트 파일 내에 한번만 나타나야 한다
  - 해시 색인을 가진 로그 세그먼트보다 몇가지 큰 장점이 있다
    - 세그먼트 병합은 파일이 사용가능한 메모리보다 크더라도 간단하고 효율적
      - 병합정렬과 유사
    - 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다
      - 특정 키들의 오프셋을 알면 그 사이만 탐색하면 됨
        - 오프셋을 알려주는 인메모리 인덱스는 필요함
    - 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기전에 압축
      - 디스크 절약 뿐만 아니라 I/O사용량도 줄임
- 데이터를 키로 정렬하고 싶다면?
  - 디스크 상에 정렬된 구조를 유지하는 것은 가능하지만 메모리에 유지하는 편이 훨씬 쉽다
    - 이런 데이터 구조를 이용하면 임의 순서로 키를 삽입하고, 정렬된 순서로 해당 키를 다시 읽을 수 있다
      - 레드블랙트리나 AVL트리같은 데이터 구조를 사용하면 됨
- LSM트리
  - 로그 구조화 병합 트리
  - 성능최적화
    - 데이터 베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있음
      - 멤테이블 확인한 다음 키가 존재하지 않는다는 사실을 확인하기 전까지 가장 오래된 세그먼트까지 거슬러 올라가야하기때문
    - 대부분 저장소 엔진은 블룸 필터를 추가적으로 사용함

### ✅ **SS 테이블 (Sorted String Table, SSTable)**

**📌 개념:**

- **정렬된 문자열 테이블**이라는 뜻으로, **불변(immutable)한 정렬된 Key-Value 쌍을 저장하는 구조**.
- 새로운 데이터는 항상 **정렬된 상태로 저장되며, 수정하거나 삭제할 수 없음**.
- 주로 **분산 스토리지 시스템**이나 **LSM-Tree 기반 DB**에서 사용됨.

**📌 특징:**

1. **불변(Immutable)한 데이터 구조**
   - 한 번 생성된 SSTable은 **변경되지 않음(append-only)**.
   - 수정이나 삭제가 필요하면 새로운 SSTable을 만들고, 오래된 SSTable을 병합(compaction)하는 방식으로 처리.
2. **이진 검색 가능 (Binary Search 가능)**
   - 데이터를 Key 기준으로 정렬해 저장하므로, **빠른 검색**이 가능.
3. **B-Tree보다 쓰기 성능이 좋음**
   - 무작위 쓰기(Random Write)가 아니라, **쓰기 작업을 메모리에서 정렬 후 한 번에 디스크에 플러시(Flush)**.

**📌 사용 예시:**

- Apache Cassandra, LevelDB, RocksDB, BigTable 등의 **LSM-Tree 기반 저장 엔진**에서 SSTable을 사용.

---

### ✅ **LSM-Tree (Log-Structured Merge Tree)**

**📌 개념:**

- **쓰기 성능을 극대화**하기 위해 설계된 **멀티-레벨 구조의 데이터베이스 인덱스**.
- SSTable을 기반으로 동작하며, 데이터를 먼저 **메모리에 쓰고 이후 배치 단위로 디스크에 플러시(Flush)**하는 방식.
- 기존 B-Tree와 비교했을 때, 무작위 디스크 쓰기(Random Write)를 줄여 **쓰기 성능이 뛰어남**.

**📌 구조:**

1. **MemTable (메모리 테이블)**
   - 데이터가 먼저 **메모리에 기록됨**(Red-Black Tree, Skip List 등 사용).
   - 일정 크기 이상이 되면 **디스크로 플러시**하여 SSTable로 저장.
2. **SSTable (Sorted String Table)**
   - 디스크에 저장된 **불변(Immutable)한 정렬된 테이블**.
   - 여러 개의 SSTable이 **컴팩션(Compaction)**을 통해 병합됨.
3. **Compaction (압축 및 병합)**
   - 오래된 SSTable을 새로운 SSTable로 병합하여 **불필요한 중복 데이터를 제거**하고 성능을 유지.
4. **Bloom Filter 적용 가능**
   - 특정 키가 존재하는지 빠르게 확인하기 위해 Bloom Filter를 사용하여 **디스크 검색 비용을 줄임**.

**📌 특징:**

- **쓰기 성능이 뛰어남**: 데이터를 메모리(MemTable)에 먼저 저장하고, 이후 배치(batch)로 디스크에 기록하여 Random Write를 줄임.
- **읽기 성능이 좋음**: SSTable이 정렬된 상태로 저장되어 있고, Bloom Filter를 활용하면 디스크 접근을 최소화할 수 있음.
- **주기적인 Compaction 필요**: 여러 개의 SSTable이 생기므로 주기적으로 정리(Compaction)해야 함.

**📌 사용 예시:**

- **NoSQL DB**: Apache Cassandra, HBase, LevelDB, RocksDB
- **키-값 저장소**: Amazon DynamoDB, Google BigTable

---

## ✅ **SS 테이블 vs LSM 트리 차이점 정리**

| 비교 항목       | SS 테이블 (SSTable)                                  | LSM 트리 (LSM-Tree)                             |
| --------------- | ---------------------------------------------------- | ----------------------------------------------- |
| **기본 개념**   | 정렬된 Key-Value 저장 파일                           | MemTable + SSTable로 구성된 계층적 구조         |
| **데이터 구조** | 단순한 정렬된 데이터 테이블                          | 여러 개의 SSTable을 컴팩션(Compaction)으로 관리 |
| **쓰기 방식**   | 불변(immutable), 직접 디스크에 기록됨                | 메모리에 먼저 기록 후, 주기적으로 디스크로 이동 |
| **읽기 성능**   | 이진 검색 가능 (빠름)                                | Bloom Filter 활용하여 빠른 검색                 |
| **쓰기 성능**   | B-Tree보다 좋지만, 다수의 SSTable을 직접 관리해야 함 | Random Write를 줄여 **쓰기 성능이 뛰어남**      |
| **삭제 처리**   | 새로운 SSTable을 생성하고, 나중에 병합하여 삭제      | Tombstone(삭제 마커)를 사용하여 정리            |
| **사용 예시**   | BigTable, HBase, RocksDB                             | Cassandra, LevelDB, DynamoDB                    |

---

### ✅ **결론**

- **LSM-Tree는 SSTable을 여러 개 사용하여 데이터 관리를 최적화**하는 방식.
- **쓰기 성능이 중요한 경우**(NoSQL, 키-값 저장소)에는 LSM-Tree가 많이 사용됨.
- **읽기 성능이 중요한 경우**(전통적인 RDBMS)에는 B-Tree 계열 인덱스가 더 적합할 수 있음.

## B트리

- 관계형 데이터베이스의 표준 색인 구현
- 비관계형 데이터베이스도 사용
- SS테이블 같이 키로 정렬된 키-값 쌍을 유지
- 수 메가바이트 이상의 가변크기를 가진 세그먼트로 나누고 항상 순차적으로 세그먼트 기록
  - B트리는 전통적으로 4k의 고정 크기 블록이나 페이지로 나누고 한번에 하나의 페이지에 읽기 또는 쓰기

### LSM트리의 장점

- B트리 인덱스는 모든 데이터를 최소한 두번 기록해야
  - 쓰기 전 로그 한번과 트리 페이지에 한번
- LSM트리는 B트리보다 쓰기 처리량을 높게 유지 가능
  - 쓰기 증폭이 더 낮음
  - 트리에서 여러 페이지를 덮어 쓰는게 아닌 순차적으로 컴팩션된 SS테이블 파일을 쓰기 때문
  - 압축률이 더 좋음
    - B트리보다 디스크에 더 적은 파일을 생성

### LSM트리의 단점

- 컴팩션 과정이 진행중인 읽기와 쓰기 성능에 영향을 줌
  - 디스크에서 비싼 컴팩션 연산이 끝날때까지 기다려야하는 상황이 발생하기 쉬움
- 높은 쓰기 처리량
  - 디스크의 쓰기 대역폭은 유한함

### 다중 컬럼 색인

- 결합 색인
  - 하나의 컬럼에 다른 컬럼 추가하는 방식
  - 하나의 키에 여러 필드를 단순히 결합
  - 전화번호부와 비슷

### 데이터 웨어하우싱

- 트랜잭션 처리 시스템
  - 직접 질의하면 비쌈
- 데이터 웨어하우스는 트랜잭션 처리시스템에 영향 주지 않고 마음껏 질의할 수 있는 데이터베이스

### OLTP(트랜잭션 처리 시스템)

- 사용자 대면이기 때문에 **대량의 요청을 받을 수 있다**
- 부하를 처리하기 위해 보통 애플리케이션이 **각 질의마다 적은 수의 레코드만 다룬다**
- 애플리케이션은 키의 일부만 사용하는 레코드를 요청하고, 저장소 엔진은 요청한 데이터를 찾기 위해 색인을 사용한다
- **디스크 탐색이 병목**

### OLAP(분석 시스템)

- 데이터 웨어하우스와 유사한 분석 시스템은 최종 사용자가 아닌 비즈니스 분석가가 주로 사용
- OLTP보다 적은 수의 질의를 다루지만 각 질의는 다루기 매우 어렵고 짧은 시간에 수백만개의 레코드를 스캔해야한다.
- 디스크 대역폭이 병목
