## 1. 왜 스프링을 썼을까?

- EJB를 쓰다가 -> 스프링을 쓰게됨
  - 3만줄로 비효율을 정리?
- JPA 표준 인터페이스
  - 구현체는 하이버네이트, Eclipse Link

## 2. 스프링 생태계

- 필수
  - 스프링 프레임워크 스프링부트(설정 편하게)
- 스프링데이터, 스프링세션, 스프링 시큐리티, 스프링 Rest Docs,스프링 배치, 스프링 클라우드
- 핵심은 스프링 프레임워크 -> 쉽게 사용할 수 있는게 스프링 부트

## 3. 스프링 프레임워크

- 핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트
- 웹 기술 : 스프링 MVC, 스프링 Web Flux
- 데이터 접근 기술 : 트랜잭션, JDBC, ORM, XML
- 언어 : 코틀린,그루비
- 스프링 부트를 통해 -> 스프링 프레임워크 사용

## 4. 스프링부트

- Tomcat 같은 웹 서버를 내장해서 별도의 웹서버를 설치하지 않아도 됨
- 빌드->서버 띄워주는걸 한순에
- 손쉬운 빌드 구성을 위한 starter종속성 제공
  - starter가 나머리 라이브러리 땡겨줌
- 스프링과 써드파티 라이브러리 자동구성
- 메트릭, 상태확인, 외부구성 같은 프로덕션 준비기능 제공

## 5. 스프링 단어?

- DI 컨테이너
- 스프링 프레임워크
- 스프링부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

## 6. 왜 만들었을까?

- 핵심 컨셉
  - 자바 언어 기반의 프레임워크
  - 객체지향 언어
  - 좋은 객체 지향 애플리케이션을 개발할수 있게 도와주는 프레임워크
  - EJA 는 객체지향의 장점을 훼손함
  - 스프링 DI 컨테이너가 객체지향을 도와주는

## 7. 좋은 객체지향 프로그래밍

- 유연하고 변경이 용이
  - 레고 블럭 조립하듯이
  - 다형성

## 8. 다형성

- 왜 다형성이 중요할까?
  - 역할과 구현으로 세상을 구분한다고 가정.
  - 역할이 인터페이스
  - 예를 들어, k3 -> 테슬라를 탄다고 했을 때 운전면허를 다시 딸 필요 없음 , 운전 가능!
  - 클라이언트가 자동차의 내부 구조 몰라도 됨
  - 자동차 기능을 무한히 확장 가능하다!
  - => why? 역할과 구현으로 세상 구분했기에 가능
- 역할과 구현을 분리
  - 클라이언트는 내부구조를 몰라도 된다.
  - 내부구조가 변경되어도 영향을 받지 않는다.
  - 구현 대상 자체를 변경해도 영향 받지 않는다.
- 역할 : 인터페이스 , 구현 : 인터페이스를 구현한 클래스

## 9. 객체의 협력이라는 관계

- 클라이언트 : 요청, 서버 : 응답

## 10. 자바 언어의 다형성

- 오버라이딩
  - 상속받은 메서드 재정의
- 오버로딩
  - 같은 이름의 함수를 여러개 정의
- 다형성의 본질
  - 인터페이스 구현한 객체 인스턴스를 실행시점에 유연하게 변경가능
- 역할과 구현 분리
  - 유연하고 변경이 용이
  - 확장 가능한 설계
  - 클라이언트에 영향 주지 않고, 변경!
  - 인터페이스를 안정적으로 잘 설계하는 것이 중요

## 11. 스프링과 객체지향

- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전 (IoC), 의존관계 주입 (DI)는 다형성을 활용해 역할과 구현을 편리하게 다룰수 있도록 지원

## 12. 좋은 객체지향 설계의 5가지 원칙(SOLID)

- SRR : 단일 책임 원칙
  - 한 클래스는 하나의 책임만
  - 중요한 기준은 변경!
    - 계층적으로 구조를 나눠서 변경시 용이하게
- ✅ OCP : 개방-폐쇄 원칙
  - 가장 중요함
  - 코드의 변경없이 기능 추가
  - 인터페이스 구현한 새로운 클래스 하나 만들어서 새로운 기능 구현
- LSP : 리스코프 치환 원칙
  - 프로그램의 정확성 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 하위 클래스는 인터페이스 규약을 다 지켜야한다.
  - 규약이 중요
- ISP : 인터페이스 분리 원칙
  - 특정 클라이언트 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- ✅ DIP : 의존관계 역전 원칙
  - 추상화에 의존해야
  - 구체화에 의존하면 안됨
  - 역할에 의존해야함
  - 즉, 인터페이스만 집중해야 (클래스에 집중하면 안됨)
  ```
  MemberRepository m = new MemoryMemberRepository();
  ```
  - 구현 클래스를 직접 선택하면 안된다!
    - DIP 위반!
- 도대체 어떻게 해야해?!
  - 다형성 만으로는 OCP, DIP를 지킬 수 없다!!
  - DI : 의존관계, 의존성 주입
  - DI 컨테이너
- +) DI 할때 권장하는 방식
  ```

  ```

````

```java
@Service
public class UserServiceImpl implements UserService {
    private UserRepository userRepository;
    private MemberService memberService;
    @Autowired
    public UserServiceImpl(UserRepository userRepository, MemberService memberService) {
        this.userRepository = userRepository;
	this.memberService = memberService;
    }
}
````

-
- 왜 생성자 주입을 해야할까?
  - 객체의 불변성확보
  - final 키워드 작성 및 lombok결합
  - 순환참조 에러 방지
