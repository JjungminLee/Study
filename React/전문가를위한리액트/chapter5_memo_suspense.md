## React.memo

- 메모화
  - 함수의 출력을 저장해두었다가 같은 입력을 사용해 함수를 다시호출하면 출력을 다시 계산하지 않고 캐시된 결과를 반환
- 메모화는 함수의 순수성을 필요로 한다
  - 함수가 주어진 입력에 대해 동일한 출력을 예측가능하게 반환해야
- React.memo는 프롭에 얕은 비교를 수행해 프롭의 변경여부 확인
  - 자바스크립트의 스칼라 타입 즉 원시타입은 매우 정확하게 비교할수 있지만
  - 그게 아니면 어려움
    - 참조타입의 경우 내용이나 값이 아닌 메모리 참조를 기준으로 한다!
- 자바스크립트는 함수를 참조로 비교함
  - 프롭이 다르면 컴포넌트가 메모화 되지 않는다!
  - 그러면 함수는 메모화할수 없는걸까?
    - useCallback으로 해결
- React.memo는 부모로부터 전파되는 리렌더링을 피하기 위해 만들어짐
  - 그렇다고 컴포넌트가 절대 리렌더링 되지 않는것은 아니다!
  - React.memo는 컴포넌트 상태나 컨텍스트 변경에 의해 예정된 업데이트가 없고, 기존 프롭과 새 프롭을 비교한 결과 두 프롭이 동일하면 다시 렌더링되지 않는다!
  - 프롭 비교시 기본값으로 제공되는 얕은 비교함수 또는 사용자가 제공하는 비교함수 사용

## useMemo

- React.Memo
  - 전체컴포넌트를 메모화해 렌더링이 다시 발생하지 않게한다.
- useMemo
  - 컴포넌트 내부의 특정 계산을 메모화해 비용이 많이드는 재계산 피하기
- useMemo 나쁜 사례
  - 계산 비용이 많이 드는 연산을 메모화하거나 객체와 배열에 대한 안정적인 참조를 유지하는데 유용
  - 문자열,숫자,불리언 같은 원시타입은 사용할 필요가 없다!

```
const[count,setCount]=useState(0);
const increment = useCallback(()=>setCount((oldCount)=>oldCount+1),[setCount]);

<button onClick={increment}>증가</button>
```

- 메모화 해야할까?
  - 아니다!
  - button은 브라우저 네이티브 엘리먼트로서 호출할수 있는 엘리먼트가 아니다!
  - 이런 내장 컴포넌트는 프롭을 사용자 정의 컴포넌트와 다르게 취급한다
    - 직접 전달
      - onClick같은 이벤트 기반의 프롭의 경우, DOM에 직접 추가하는 대신 이벤트 위임을 통해 이벤트 처리
      - 최상위 수준에 한개의 이벤트 리스너 추가하고 여기서모든 이벤트 수신
    - 렌더링 동작
      - 내장 컴포넌트는 리렌더링 된 상위 컴포넌트의 일부가 아니라면 함수 프롭의 변경에 의해서는 리렌더링 되지 않음
    - 함수에 대한 가상 dom과 비교하지 않음
      - 인라인 함수를 버튼에 전달하면 컴포넌트가 렌더링될때마다 새로운 함수가 되지만 리액트는 변경사항 감지를 위해 깊은 비교 수행 안함
    - 이벤트 풀링
      - 이벤트 핸들러에 이벤트 풀링을 이용해 메모리 부하 줄임
- 사용자 정의 컴포넌트
  - 새 함수를 프롭으로 전달하면 자식컴포넌트가 순수 컴포넌트거나 메모화가 적용된 경우 프롭의 변화 감지해 리렌더링
  - 내장 컴포넌트는 이득없이 부하만 추가

#### 언제 useCallback을 쓰면 좋을까?

- 자주 리렌더링 될 가능성이 있는 컴포넌트가 있고 하위컴포넌트에 콜백 전달할때

```
const ExpensiveComponent = React.memo(({onButtonClick})=>{
겁나 비싼 작업하는 중
});

const incrementCount = useCallback(()=>{
setCount(prev=>prev+1);
},[setCount]);

return (


<ExpensiveComponent onButtonClick={incrementCount}/>
)
```

## 지연로딩

- 자바스크립트를 너무 많이 전달하면
  - 로딩시간 느려짐
  - 데이터 사용량 증가
- 해결하는 방법
  - 코드 분할을 사용해 특정 페이지나 기능에 필요한 자바스크립트만 읽어들이기
  - 지연로딩
    - 페이지가 완전히 읽어들여질때까지 초기 실행에 필수적이지 않은 자바스크립트의 로딩 미루기!
    - 필요할때만 읽어들여서 페이지 로드 시간과 데이터 사용량 줄이기

#### React.Lazy,Suspense를 사용해 지연로딩

```
const sideBar = lazy(()=>import("./Sidebar"));

return(
	<Suspense fallback={<FakeSideShell/>}>
		{showSideBar&&<Sidebar/>}
	</Suspense>
)
```

- lazy
  - 실제로 렌더링 되기전에는 내부의 컴포넌트를 호출하지도, 읽지도 않는다
- suspense
  - 트리에서 대상이 되는 컴포넌트를 Suspense로 감싼다
  - 프라미스가 해결되기 전까지 폴백 컴포넌트를 표시할 수 있다!
    - 가짜 사이드바를 표시!
  - 지연로딩이 필요한 컴포넌트를 감싸는 용도로만 사용해야한다

## useState와 useReducer

- useState가 내부적으로 useReducer사용
