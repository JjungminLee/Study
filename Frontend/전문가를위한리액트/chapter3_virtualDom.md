- 가상 DOM은 평범한 JS객체로 구성됨
- setState로 UI변경하면 가상 DOM을 먼저 업데이트 -> 가상 돔의 변경사항에 맞춰 실제 돔 업데이트
  - 이런 과정을 재조정
- 가상 돔을 업데이트 하는 이유?
  - 실제 돔의 업데이트가 다소 느리고 비용이 들음
  - reflow와 repaint가 필요

## 실제 DOM의 문제점?

### 성능이 별로임

- 브라우저에서 레이아웃 다시 계산하고 영향받은 부분 다시 그려야함
- CPU의 처리 성능은 애플리케이션의 성공에 큰 영향을 미친다

### 브라우저 간 호환성

- 브라우저마다 문서 모델링 방식이 달라 일관성이 보장되지 않음
- 특정 DOM앨리먼트와 속성을 지원하지 않는 브라우저가 있을수도 있음
  - 리액트의 synthetic event system이 이를 해결
    - 통합 인터페이스를 제공해 이벤트 속성에 접근하기 용이하게 한다
    - 이벤트 위임
      - 이벤트 리스너를 앨리먼트에 추가하지 않고 루트에서 이벤트를 받는다.
        - 구형 브라우저의 특정 앨리먼트에서 일부 이벤트를 사용할수 없는 문제 해결

## Fragment

https://react.dev/reference/react/Fragment

- <></>
- DOM 노드를 저장하는 가벼운 컨테이너
  - 기본 DOM에 영향을 주지 않고 여러가지 업데이트 수행할 수 있는 임시 저장소처럼 동작
- 성능상 이점?
  - 일괄 업데이트
    - 실제 돔을 여러번 개별적으로 업데이트 하는게 아닌 모든 변경사항을 일괄적으로 업데이트
  - 리랜더링 방지
    - 프레그먼트는 활성화된 문서 DOM트리에 포함되지 않음!
    - 변경해도 실제 문서에는 적용되지 않는다!

### 가상 DOM은?

- 프레그먼트를 좀더 나은 방식으로 구현
- 일괄 업데이트
  - 리액트는 상태나 props가 변경시 실제 DOM을 직접 변경하는데 반해 가상 DOM은 변경 사항 먼저 적용
- 효율적인 비교 알고리즘
- 단일 렌더링
  - 차이점 식별시 단 한번의 일괄처리 통해 실제 DOM업데이트

## 가상 DOM의 작동방식

- 메모리에 DOM의 가상표현을 만들고 나면 -> 실제 DOM 수정하지 않고도 가상 표현을 변경 가능

### 리액트 엘리먼트

    - typeof
    	- 객체가 유효한 앨리먼트인지 확인할때 사용하는 특수한 심벌
    	- Symbol(react.portal)
    		- 앨리먼트가 리액트 포털을 나타내는 경우

### type

    - 컴포넌트의 종류를 알려준다
    - <div> -> dom 앨리먼트
    	- 이런 돔 앨리먼트를 호스트 컴포넌트라고도 한다.

```
const MyComponent=()=>{
}
```

- 이 경우 타입은 MyComponent임

### ref

- 부모 컴포넌트는 이 속성을 사용해 기본 DOM 노드에 대한 참조를 요청할 수 이다
- 보통 DOM을 직접 조작해야하는 경우 사용

### props

- 컴포넌트에 전달된 모든 속성과 프롭을 포함하는 객체

#### **1. `props` (복수형) – 모든 속성을 담고 있는 객체**

✅ **`props`는 컴포넌트에 전달된 모든 속성을 포함하는 객체
즉, **`props`는 여러 개의 prop을 포함하는 "컨테이너" 역할\*\*

### **💡 예제**

`function UserInfo(props) {   return (     <div>       <h1>{props.name}</h1>       <p>Age: {props.age}</p>     </div>   ); }  // 사용 예시 <UserInfo name="Alice" age={25} />`

✅ `props.name` → `"Alice"`  
✅ `props.age` → `25`  
✅ **여기서 `props`는 `{ name: "Alice", age: 25 }` 객체를 의미**

---

#### **2. `prop` (단수형) – 개별 속성**

✅ **`prop`은 `props` 객체 안에 있는 특정 속성(값)**을 의미
즉, `prop`은 `props` 객체의 한 요소일 뿐

### **💡 예제**

`function UserInfo(props) {   const prop = props.name; // 단일 속성 사용   return <h1>{prop}</h1>; }`

✅ `props` 객체에서 `name` 속성만 가져와서 `prop`으로 저장

### \_owner

- 프로덕션 빌드가 아닐때만 접근할 수 있는 속성
- 이 엘리먼트를 생성한 컴포넌트를 추적하기 위해 리액트 내부적으로 사용
- 애플리케이션 코드에서 절대 사용 불가

#### \_\_Store

- 앨리먼트의 추가 데이터 저장하기 위해 리액트가 내부적으로 사용하는 객체
- 직접 접근 불가

## 가상 DOM vs 실제 DOM

- 가상 DOM
  - React.createElement
- 실제 Dom
  - document.createElement
- 재조정 프로세스
  - 리액트 컴포넌트가 렌더링 되면 리액트는 새로운 가상 DOM트리를 생성하고 이전 가상 DOM트리와 비교한 다음 이전 트리를 새 트리와 일치하도록 업데이트하는데 필요한 최소 변경횟수 계산
  - 리액트의 Diffing 알고리즘
    - 두 트리의 루트에 있는 노드가 다른 경우 리액트는 기존 트리 전체를 새로운 트리로 대체
    - 루트 노드가 동일하다면 리액트는 노드의 속성이 변경된 경우에만 업데이트
    - 자식 노드가 다른 경우 리액트는 변경된 자식 노드만 업데이트
      - 하위 트리 전체를 다시 생성하지 않고 변경된 노드만 업데이트
    - 노드의 자식들이 동일하지만 순서가 변경된 경우 리액트는 노드를 다시 생성하지 않고 실제 DOM에서 노드의 순서를 다시 설정
- 리렌더링
  - 리액트가 각 함수 컴포넌트를 재귀적으로 호출하면서 프롭을 인수로 각 함수 컴포넌트에 전달한다는 의미
  - 프롭이 변경되지 않은 컴포넌트도 무시하지 않고 상태나 프롭이 변경된 부모 컴포넌트의 모든 자식 컴포넌트를 호출
  - useMemo 같은 최적화 기능을 통해 리렌더링을 피할 수 있다

### Diffing 알고리즘의 최적화 (Fiber Reconciliation)

https://velog.io/@jangws/React-Fiber

### **🔥 React Fiber (2017~)**

React는 **Fiber Reconciliation(파이버 조정)**이라는 새로운 알고리즘을 도입해,  
기존 Diffing 알고리즘보다 **더 빠르고 효율적인 업데이트가 가능**하도록 개선

✅ **React Fiber의 목표**

- 리액트가 스케쥴러의 이점을 잘 활용할 수 있게 하는 것
- 일을 잠시 멈추고 나중에 다시 돌아오기
- 다른 유형의 일에 우선권 부여하기

✅ **React Fiber의 핵심 개념**

1. **작업을 여러 프레임에 나누어 수행 (Interruptible rendering)**
   - 즉, 렌더링이 너무 오래 걸리면 중단하고, 다음 프레임에서 이어서 수행 가능
2. **우선순위 기반 업데이트**
   - 사용자 입력, 애니메이션과 같은 중요한 작업은 먼저 처리하고, 덜 중요한 작업은 나중에 처리
3. **부분적인 렌더링 가능 (Time-Slicing & Suspense 지원)**
   - 즉, 전체 컴포넌트를 한 번에 업데이트하는 것이 아니라 **부분적으로 업데이트** 가능
