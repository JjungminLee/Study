## 5장

### 책임주도설계

- 데이터보다 행동을 먼저 결정
- 협력이라는 문맥안에서 책임 결정
- 메세지를 전송하려는 클라이언트의 의도에 적합한 책임을 할당해야
- 이 클래스는 무엇을 해야하지 (X) 메세지를 전송해야하는데 누구한테 전송해야하지? (O)

### 변경되는 코드의 기준은 뭐지?

- 인스턴스 변수가 초기화되는 시점
  - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
- 메서드들이 인스턴스 변수를 사용하는 방식
  - 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다
  - 응집도를 높이기 위해서는 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야

### 구현을 공유할 필요가 있다면

- 추상 클래스를 사용하기
- 구현을 공유할 필요가 없다면 → 인터페이스

### 응집도가 낮은 메서드

- 로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분
- 메서드를 작게 분해해서 메서드의 응집도를 높이기

## 6장

### 메세지

- 객체의 품질을 결정
- 메서드 : 메세지에 응답하기 위해 실행되는 코드 블럭
- 퍼블릭 인터페이스 : 객체가 협력하여 참여하기 위해 외부에서 수신할 수 있는 메세지의 묶음
- 메서드 인자로 전달할때 screening.code 같이 필드를 노출하지 말고 걍 screening만 보내라
  - 오직 하나의 도트만 사용

```java
screening.getMovie().getCondition(); // 이딴 짓 하지마라
```

- 메서드를 만들때 어떻게 하느냐가 아닌 무엇을 하느냐에 따라 메서드 이름을 짓기
  - 의도를 드러내는 선택자

### 기차 충돌

- getter연속으로 여러개 쓰는거
- 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙 위반
- 객체의 내부구조는 구현에 해당

### 묻지말고 시키기

- 자신의 상태를 스스로 관리하고 결정하게 하기!
- 제어의 흐름을 객체 자신에게 가져가게!
  - 이러면 기차충돌을 피할 수 있다!

### 디미터의 법칙

- 도트가 많아져도 어떤 정보를 외부로 노출하지 않으면 디미터의 법칙을 준수한것
- 어떨때는 물음이 필요할수 있다. 판단의 기준은 개발자의 몫

### 명령과 쿼리를 섞지 말기

- 섞게 되면 실행결과를 예측하기 어려워짐
  - 명령 : 상태를 변경할 수 있지만 반환해서는 안됨
  - 쿼리 : 상태를 반환할 수 있지만 변경해서는 안됨

## 8장

### 의존성

- 어떤 객체가 협력하기 위해 다른 객체를 필요로 할때 의존성이 생긴다
- 실행시점
  - 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야
- 구현시점
  - 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경

### 의존성 해결하기

- 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 한다.
- 컴파일 타임에는 DiscountPolicy에 의존하다가 런타임에는 AmountDiscountPolicy에 의존
- 방법
  - 객체 생성하는 시점에 생성자 통해 의존성 해결
  - 객체 생성 후 setter메서드
  - 메서드 실행 시 인자를 이용해 의존성 해결

### 바람직한 의존성

- 재사용성에 있다
- 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것 뿐
- 의존하는 대상이 더 추상적일 수록 결합도는 더 낮아진다
- 의존성은 명시적으로 표현해야한다

### new를 사용하지마라

- 결합도가 급격하게 높아지게 된다
- 해결책
  - 인스턴스 생성하는 로직과 인스턴스 사용하는 로직의 분리
- 가끔은 생성하는 경우도 있는데 이런걸 생성자 체이닝이라고 함

### 유연한 설계

- 추상화에 의존
- 생성자를 통해 의존성을 명시적으로 드러냄
- 구체클래스를 다뤄야하는 책임을 외부로 옮김
