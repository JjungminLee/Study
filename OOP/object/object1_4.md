## 간단한 정리

- 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색해라
- 책임 → 행동 → 객체보다 메서드를 먼저 고려하기
- 캡슐화 : 변화될 수 있는 어떤것이라도 다 숨기기

## 1장

### 모듈

- 크기와 상관없이 패키지, 라이브러리 같이 프로그램을 구성하는 임의 요소를 의미
- 모든 모듈은 제대로 실행되어야, 변경에 용이해야, 이해하기 쉬워야

### 의존성

- 의존성은 변경에 대한 영향을 암시한다
- 객체간 의존성이 과한 경우를 결합도가 높다
- 설계의 목표는 객체 사이의 결합도를 낮추는 것

- 구현시 다른 클래스의 상세한 내부 구현까지 알면 안된다!
- 내부에 접근하지 않는 방법을 지향해야함
  - 객체 내부 상태를 캡슐화하고, 객체 간에 오직 메세지를 통해서만 상호작용하도록 만들어야한다
- 객체지향프로그래밍은 책임을 분산

## 2장

### 객체지향

- 어떤 객체들이 필요한지 먼저 고민하기
- 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 바라보기
- 도메인 : 사용자가 프로그램을 사용하는 분야
- 설계가 필요한 이유는 변경을 관리하기 위함

### 협력의 관점

- 어떤 객체가 필요한지 결정
- 객체들의 공통 상태와 행위를 구현하기 위해 클래스 작성
- 협력에 대한 개념을 간단하게라도 살펴봐야한다
- **객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메세지를 전송하는 것**
  - **메세지 처리하는 자신만의 방법은 메서드**
  - 메세지와 메서드를 구분할줄 알아야한다

### 추상클래스와 Template Method

- DiscountPolicy가 부모 클래스고, AmountDiscountPolicy Percent DiscountPolicy를 둔다고 할때 AmountDiscountPolicy 는 인스턴스가 필요 없기때문에 추상클래스로 둔다!
- 부모 클래스에서 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식클래스에게 위임 → Template Method

### TradeOffs

- 설계가 유연해질수록 코드를 이해하고 디버깅하기 어려워짐

### 상속을 왜 쓸까?

- 코드를 재 사용하기 위함
- 상속을 통해 부모클래스와 자식 클래스가 동일한 타입으로 간주될 수 있다!

### 메세지와 메서드

- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메세지를 수신하는 객체의 클래스에 따라 달라짐
  - 다형성이라고 한다!
- 객체지향 프로그램의 컴파일시간의 의존성과 실행시간의 의존성이 다를 수 있다는 사실을 기반으로 함
- 다형적인 협력에 참여하는 객체들은 모두 같은 메세지를 이해할 수 있어야한다.
  - 인터페이스가 동일해야한다
- 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다!
  - 지연 바인딩 또는 동적 바인딩

### 구현 상속과 인터페이스 상속

- 구현 상속
  - 서브클래싱
  - 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용
- 인터페이스 상속
  - 서브 타이핑
  - 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용
- 상속은 인터페이스 상속을 써야함
- 인터페이스를 재사용할 목적으로 접근해야

### 어떻게 추상화는 유연한 설계를 가능하게 할까?

- 설계가 구체적인 상황에 결합되는 것을 방지하기 때문
  - 컨텍스트 독립성
- 유연성이 필요한 곳에 추상화를 사용하기

### 상속보다는 컴포지션(합성)

- 코드 재사용하는 방법이 합성
- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용
- 상속의 문제점?
  - 캡슐화를 위반
  - 부모 클래스와 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합

```java
public class Movie{
	private DiscountPolicy discountPolicy; // Movie가 DiscountPolicy를 포함 (HAS-A 관계)
	public void changeDiscountPolicy(DiscountPolicy discountPolicy){
		this.discountPolicy = discountPolicy;
	}
}

avatar.changeDicountPolicy(new PercentDiscountPolicy(0,1,...));
```

- 인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 합성이라고 한다
  - 위 코드에서 Movie가 DiscountPolicy를 상속받은게 아닌 객체를 직접 내부에서 참조한다
- 상속은 클래스를 통해 강하게 결합, 합성은 메세지를 통해 느슨하게 결합

## 3장

### 협력

- 객체들이 애플리케이션 기능을 구현하기 위해 수행하는 상호작용
- 객체가 협력에 참여하기 위해 수행하는 로직은 책임
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성
- 객체 사이의 협력을 사용할 수 있는 유일한 커뮤니케이션 수단
  - 메세지 전송
- 객체를 자율적으로 만드는 방법은 캡슐화
- 객체를 설계하는데 필요한 일종의 문맥
  - 협력은 객체의 행동을 결정함

### 책임

- 객체가 수행하는 행동
- 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문
- 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정
- 객체지향 설계는 시스템의 책임을 완료하는데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춤

### 1️⃣ 메세지가 객체를 결정한다

- 메세지가 객체를 선택해야한다
- 객체가 최소한의 인터페이스를 가질수 있게됨
- 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다
  - `무엇을 하는지`는 표현해야하지만
  - `어떻게 수행하는지`는 표현해서는 안된다

### 2️⃣ 행동이 상태를 결정한다

- 객체가 존재하는 이유는 협력에 참여하기 위해
- 객체가 협력에 적합한지 결정하는 것은 객체의 상태가 아닌 행동

### 역할을 어떻게 구현하지?

- 추상클래스와 인터페이스를 통해
- 추상클래스 : 책임의 일부를 구현
- 인터페이스 : 일체의 구현없이 책임의 집합만을 나열
- 협력 → 역할 → 객체 → 클래스

## 4장

- 결합도와 응집도를 합리적인 수준으로 유지하는 방법은 객체의 행동에 초점을 맞추는 것!

### 캡슐화

- 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법

### 응집도

- 모듈에 포함된 내부 요소들이 연관돼 있는 정도
- 긴밀하게 협력한다면 높은 응집도

### 결합도

- 의존성의 정도

### 좋은 설게

- 오늘의 기능을 수행하면서 내일의 변경을 수행할수 있어야
- 높은 응집도와 낮은 결합도
- 데이터를 처리하는 데 필요한 메서드를 데이터를 가지고 있는 객체 스스로 구현

### 나쁜 설계

- 데이터 중심 설계
  - 이 객체에 어떤 데이터가 포함되어야 하는가
- 코드 중복
- 접근자와 수정자가 많으면 public이랑 다를바가 없다
- 필드가 노출되어서는 안된다
