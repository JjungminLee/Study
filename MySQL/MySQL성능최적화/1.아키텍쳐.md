## 동시성 제어

### 잠금

- 테이블 잠금
- 행 잠금
  - 스토리지 엔진에서 함
  - 리소스가 큼

### 격리수준

### Read uncommitted

- 커밋되지 않은 트랜잭션의 결과를 볼수 있다
  - 커밋되지 않은 데이터를 duty read
- 트랜잭션과 관계없이 가장 최신의 데이터만 읽으려함

### Read committed

- 기본 격리 수준
- 이전에 사용된 격리의 정의를 충족하여 트랜잭션이 시작된 후 커밋된 트랜잭션으로 인한 변경 사항 계속 확인 가능, 커밋될때까지 변경사항은 다른사람에게 표시 되지 않음
  - 트랜잭션이 실행 중이라도 **다른 트랜잭션이 커밋하면 새 데이터를 읽을 수 있음.**
- Nonrepeatable Read를 허용함
  - 같은 트랜잭션에서 **같은 데이터를 두 번 읽었을 때 값이 달라지는 것.**
- 동일한 명령문을 두번 실행하면 다른 데이터를 볼 수 있음

### Repeatable Read

- Read commited의 문제 해결
  - **트랜잭션 내에서 동일한 데이터를 계속 읽을 수 있음.**
  - 즉, **Non-repeatable Read 문제 해결!**
- 트랜잭션이 읽는 모든 행이 동일한 트랜잭션 내에서 후속 읽기에서 '동일하게 보이도록'하지만 이론적으로 문제인 팬텀리드 허용
- 팬텀리드란?
  - 특정 조건으로 **조회할 때, 트랜잭션 도중 새로운 데이터가 추가되면 결과가 달라지는 것.**
- 특정 범위의 행 선택하고 다른 트랜잭션이 그 범위에 행을 삽입한 다음, 동일한 범위를 다시 선택하면 팬텀리드 발생 가능

### Serializable

- 가장 높은 격리 수준
- 모든 `팬텀 리드`, `Non-repeatable Read`, `Dirty Read` 문제 해결!
- 트랜잭션이 충돌하지 않도록 강제로 트랜잭션을 정렬하여 팬텀읽기 문제 해결
- 모든 행에 잠금 설정
- 많은 시간이 소요되고 잠금 경합 발생 가능

## 교착상태

- 각 트랜잭션이 첫번째 쿼리를 실행하고 데이터 행을 업데이트하여 기본 키 인덱스에서 해당 행을 잠그고 프로세스에 속한 모든 추가 고유 인덱스에서도 행을 잠금 그런 다음 각 트랜잭션은 두번째 행을 업데이트하려고 시도하지만 이미 잠긴 상황
- InnoDB에서는 순환종속성을 감지하고 오류를 즉시 반환
  - 배타적 행 잠금이 가장 적은 트랜잭션을 롤백

## MySQL에서의 트랜잭션

- InnodDB가 최고의 표준

### AutoCommit

- insert,update,delete문은 트랜잭션으로 처리되어 즉시 커밋됨
- 이 모드를 AutoCommit이라 하고, 이걸 비활성화 하면 일련의 구문을 최종적으로 커밋혹은 롤백 가능
- MySQL은 SET TRANSACTION ISOLATION LEVEL을 사용해 격리수준 설정 가능

### 트랜잭션에서 스토리지 엔진 혼합

- 서버 수준에서 트랜잭션 관리 안함, 기본 스토리지 엔진이 트랜잭션 자체를 구현함
- 각 테이블에 적합한 스토리지 엔진을 선택하고 비용이 들더라도 애플리케이션 로직에서 스토리젠진을 혼용하는 것을 피해야

### 암시적 잠금과 명시적 잠금

- InnoDB는 2단계 잠금 프로토콜 사용
- 트랜잭션 중 언제든지 잠금을 획득할 수 있지만, 커밋과 롤백이 되지 전까지 잠금을 해제하지 않음
- 모든 잠금은 동시에 해제됨
- InnoDB는 행 수준 잠금을 지원하기 때문에 LOCK TABLES는 필요하지 않다!

## 다중 버전 동시성 제어

- MVCC라고 함
  - 오라클, postrge에도 존재
- 행 수준 잠금의 변형
- 특정 시점 존재했던 데이터의 스냅샷을 사용하여 작동함
- 트랜잭션은 실행기간에 관계없이 데이터를 일관되게 볼수 있음
- 트랜잭션 마다 동일한 테이블에서 다른 테이블을 동시에 볼 수 있음
- Reatable Read, Read commited 격리수준에서만 작동
- 쿼리가 트랜잭션에 부합하는 버전의 행을 읽지 않기 때문에 Read uncommited 는 mvcc와 호환되지 않음
  - 🔍 **쉽게 말하면**
  - **MVCC는 트랜잭션마다 "자기만의 데이터 스냅샷"을 사용해 일관성을 유지**하려고 합니다.
  - **하지만 `READ UNCOMMITTED`는 최신 데이터(심지어 커밋되지 않은 데이터까지)를 읽으려고 합니다.**
  - **이 두 개념은 근본적으로 충돌**하기 때문에, `READ UNCOMMITTED`는 MVCC와 호환되지 않는다고 하는 것입니다.
- 최신 버전만 읽고, 읽기는 반환하는 모든 행을 잠그기 떄문에 Serializable는 mvcc와 호환되지 않음
  - Serializable 방식은 읽기 시에도 모든 행을 잠그므로, MVCC가 제공하는 비잠금 읽기의 장점을 활용할 수 없어 둘이 호환되지 않는다는 의미

### InnoDB의 경우

- 트랜잭션마다 트랜잭션 id를 할당하여 mvcc구현
- id는 트랜잭션이 처음 읽을때 할당됨

## 복제

- MySQL은 지정된 시간에 한 노드에서 쓰기를 허용하게 설계됨
- 이렇게 하면 일관성을 관리하는데 이점이 있으나, 여러 서버또는 여러 위치에 데이터 기록해야하는 경우 트레이드 오프가 필요
- 한 노드가 사용하는 쓰기를 추가 노드에 배포하는 기본적인 방법 제공
  - 이를 복제라고 함

## 가용성 확인 방법?

- 클라이언트 또는 원격의 엔드포인트에서 확인하는 것

### 고객에게 직접적인 영향이 없는 모니터링 가능한 유용한 신호

1. 디스크 증가
   - 디스크가 너무 빨리 채워지는 원인?
     - 언두 로그가 크거나
     - 테이블 변경이 있는 장기 실행 트랜잭션
   - 디스크가 쓸 수 있는 최대 처리량 평가하여 디스크 채우는데 걸리는 최대 트래픽 처리량 계산하기
2. 연결 증가
3. 복제 지연
   - 원본에 기록중인 데이터와 레플리카에서 사용 가능한 데이터 사이의 지연
   - 변경 사항을 따라잡지 못한 레플리카 때문에 발생
4. I/O 활용
   - iostat활용
   - I/O대기 상태 모니터링
5. 자동 증가 공간
   - auto increment pk가 기본적으로 부호를 가진 정수로 생성되어 키 공간이 부족해짐
     - auto increment pk사용하는 모든 테이블에 대해 남은 정수공간 모니터링
