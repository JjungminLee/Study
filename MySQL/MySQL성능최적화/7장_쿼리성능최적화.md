## 응답시간이 중요하다

- 쿼리를 최적화 하기 위해서 해당 하위 작업 제거, 발생횟수 줄이기, 더빠르게 수행해야하는 하위작업 최적화 해야

## 왜 쿼리가 느릴까?

- 너무 많은 데이터를 사용해서
  - 애플리케이션이 필요 이사으로 많은 데이터를 검색하는지 확인한다
  - MySQL서버가 필요 이상으로 많은 행을 분석하는지 확인한다
- 필요 이상의 행, 다중 조인, 모든 열 가져오기, 동일한 데이터 반복적으로 가져오기 모두 조심!
- 넘 많은 데이터를 검사해서
  - 쿼리비용 메트릭
    - 응답시간
    - 검사된 행 수
    - 반환된 행수

## 응답시간

- 서비스 시간 + 대기열 시간의 합
  - 서비스 시간 : 서버가 실제로 쿼리 처리하는데 걸리는 시간
  - 대기열 시간 : 서버가 실제로 쿼리를 실행하지 않는 응답시간 예를 들어 I/O작업 대기, 행잠금 기다리기
- I/O , 잠금 대기
  - 성능에 큰 타격!

## 검사된 행과 반환된 행

- 쿼리가 얼마나 효율적으로 필요한 데이터를 찾고 있는지 확인하는 방법
  - 검사되는 행의 수 고려하기
    - 검사되는 행?
      - MySQL이 `SELECT` 문을 실행할 때, 특정 조건(`WHERE`)을 만족하는 데이터를 찾기 위해 **실제로 몇 개의 행(Row)을 읽었는지**를 나타냄.
      - EXPLAIN 키워드를 통해 할 수 있다!'
  - 쿼라 비용 고려시 -> 단일 행 찾는 비용 고려하기!

## 어떻게 쿼리를 재구성하지?

### 단순한 쿼리가 답은 아니다

- MySQL은 이미 효율적으로 연결및 연결해제를 처리하기 때문에 간단한 쿼리에 매우 빠르게 응답함
- 2000개 이상의 qps를 실행가능
  - **QPS (Queries Per Second, 초당 쿼리 수)** 는 **데이터베이스가 초당 처리하는 쿼리(Query)의 개수**
- 오히려 너무 많은 쿼리로 쪼개서 사용하면 더 성능이 저하될 수 있다

### 조인을 분해하자

## MySQL이 수행할 수 있는 최적화

- 최적의 조인 순서를 정하기
- outer join을 Inner join으로
- count(),min(),max() 최적화
